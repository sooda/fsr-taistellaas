/**

This file is part of MaCI/GIMnet.

MaCI/GIMnet is free software: you can redistribute it and/or modify it 
under the terms of the GNU Lesser General Public License as published 
by the Free Software Foundation, either version 3 of the License, or 
(at your option) any later version.

MaCI/GIMnet is distributed in the hope that it will be useful, but WITHOUT 
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public 
License for more details.

You should have received a copy of the GNU Lesser General Public 
License along with GIMnet. (See COPYING.LESSER) If not, see 
<http://www.gnu.org/licenses/>.

**/
/**
 * \file
 * \brief J2B2 API header
 * \author Antti Maula <antti.maula@tkk.fi>
 */

#ifndef _J2B2_API_HPP_
#define _J2B2_API_HPP_


//*****************************************************************************
//*****************************************************************************
#include "MachineCtrlClient.hpp"
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

/**
 * Constants for joint controller. This controller controls CameraPTU,
 * as well as any User Defined servos. Special 'channel numbers'
 * defines which Servo the command applies to.
 * 
 * These values should be passed as:
 * iServoCtrl->SetPosition( KServo..., yourvalue );
 */
enum EServo { 
  KServoCameraPTUPan = 0,     ///< Camera PTU - Pan
  KServoCameraPTUTilt = 1,    ///< Camera PTU - Tilt
  KServoUserServo_0 = 2,      ///< User defined servo 0 (on Ch 2)
  KServoUserServo_1 = 3,      ///< User defined servo 1 (on Ch 3)
  KServoUserServo_2 = 4,      ///< User defined servo 2 (on Ch 4)
  KServoUserServo_3 = 5       ///< User defined servo 3 (on Ch 5)
};


class CJ2B2Client {
public:
  inline CJ2B2Client();
  inline ~CJ2B2Client();


  /** Open J2B2 Client.
   *
   * This function attempts to connect, and open the J2B2 Client. The
   * function requires the Access Point hostname and port as
   * parameters. Others are optional, and are usually fine with their
   * default values.
   *
   * After calling this function, and receiving a 'true' value, the
   * application may use any validated interface through the
   * appropriate interface pointer. An interface has been validated
   * when the interface pointer has a non-NULL value.
   *
   * @param[in] aGIMnetAPHost GIMnetAP Host designator string. For example, 'localhost'
   * @param[in] aGIMnetAPPort GIMnetAP port number. For example, 40002
   * @param[in] aOwnName Name of this connecting application. Use empty 
   *            string for autogenerated default name.
   * @param[in] aMaCIGroup MaCI Groupname to search for. Default for J2B2 is 'J2B2'.
   *
   * @return This function returns 'true', if it was able to connect,
   * and look for services with given parameters AND found atleast one
   * service. However, as application needs vary, this function does
   * not attempt to make any decisions about what interfaces are
   * really needed. Hence, the application may check the result of the
   * open operation by checking the required interface pointers (for
   * example: 'iImageCameraFront'. If the application has all the
   * pointers it needs, then the Open has succeeded. Otherwise, the
   * application may decide that all required interfaces are not
   * available and exit. If this function returns 'false', then the
   * API failed to connect and/or search for services. When 'false' is
   * returned, there is no need to check any interface pointers for
   * validity, as they will all be invalid (NULL). To put it short:
   * when 'true' is returned, there _MAY_ be services available, but
   * when 'false' is returned, there was an critical error and no
   * interfaces were detected.
   *
   */
  inline bool Open(const std::string &aGIMnetAPHost,
                   const unsigned int &aGIMnetAPPort,
                   const std::string &aOwnName="",
                   const std::string &aMaCIGroup="J2B2");
  
public:
  MaCI::Image::CImageClient *iImageCameraFront;             ///< Front camera
  MaCI::JointGroupCtrl::CJointGroupCtrlClient *iServoCtrl;  ///< PTU of camera
  MaCI::SpeedCtrl::CSpeedCtrlClient *iMotionCtrl;           ///< motion control
  MaCI::Position::CPositionClient *iPositionOdometry;       ///< Odometry source
  MaCI::Behaviour::CBehaviourClient *iBehaviourCtrl;        ///< Behaviour control
  MaCI::Ranging::CRangingClient *iRangingLaser;             ///< Laser scanner
  MaCI::Ranging::CRangingClient *iRangingBumpers;           ///< Bumpers
  MaCI::IO::CIOClient *iIOBoardAD5414;                      ///< IO Board bound to AD5414-io.
  MaCI::IO::CIOClient *iIOBoardESC;                         ///< IO Board bound to ESC-io. OUT: 8-15, IN: 16-23
  MaCI::Text::CTextClient *iTextToSpeech;                   ///< Text To Speech client.

private:
  MaCI::MachineCtrl::CMachineCtrlClient *iMachine;          ///< Internal device enumerator class

private:
  CJ2B2Client(const CJ2B2Client &) 
  : iImageCameraFront(NULL),iServoCtrl(NULL),iMotionCtrl(NULL),iPositionOdometry(NULL),
    iBehaviourCtrl(NULL),iRangingLaser(NULL),iRangingBumpers(NULL),iIOBoardAD5414(NULL),
    iIOBoardESC(NULL),iTextToSpeech(NULL),iMachine(NULL) {}
  const CJ2B2Client &operator=(const CJ2B2Client &) { return *this; }

};
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//*** Inline implementations **************************************************
//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

CJ2B2Client::CJ2B2Client() :
  iImageCameraFront(NULL),iServoCtrl(NULL),iMotionCtrl(NULL),iPositionOdometry(NULL),
  iBehaviourCtrl(NULL),iRangingLaser(NULL),iRangingBumpers(NULL),iIOBoardAD5414(NULL),
  iIOBoardESC(NULL),iTextToSpeech(NULL),iMachine(NULL)
{
}
//*****************************************************************************

CJ2B2Client::~CJ2B2Client()
{
  if (iMachine) {
    delete iMachine;
    iMachine = NULL;
  }
}
//*****************************************************************************

bool CJ2B2Client::Open(const std::string &aGIMnetAPHost, 
                       const unsigned int &aGIMnetAPPort, 
                       const std::string &aOwnName, 
                       const std::string &aMaCIGroup) 
{
  bool result = false;
  
  // Instantiate
  iMachine = new MaCI::MachineCtrl::CMachineCtrlClient(aGIMnetAPHost, aGIMnetAPPort, aOwnName, aMaCIGroup);
  
  // Get component list
  MaCI::MachineCtrl::TMaCIMachineComponents comp;
  iMachine->GetMachineComponents(comp);
  
  // If the list has any components ...
  if (comp.size() > 0) {
   
    iImageCameraFront = iMachine->GetImageClient("CameraFront", true);
    iServoCtrl = iMachine->GetJointGroupCtrlClient("ServoCtrl", true);
    iMotionCtrl = iMachine->GetSpeedCtrlClient("Drive2D", true);
    iPositionOdometry = iMachine->GetPositionClient("Motion", true);
    iBehaviourCtrl = iMachine->GetBehaviourClient("AvoidHit", true); 
    iRangingLaser = iMachine->GetRangingClient("Laser", true);
    iRangingBumpers = iMachine->GetRangingClient("Bumpers", true);
    iIOBoardAD5414 = iMachine->GetIOClient("AD5414", true);
    iIOBoardESC = iMachine->GetIOClient("Motion", true);
    iTextToSpeech = iMachine->GetTextClient("TTS", true);

    result = true;

  } else {
    // No components! Propably error connecting.
    dPrintLCRed(ODERROR,"WARNING: No services found with given parameters!");
    dPrintLCRed(ODERROR,"Are you using the correct GIMnetAP (was: '%s'), and port (was: %d)?",
                aGIMnetAPHost.c_str(), aGIMnetAPPort);

  }

  return result;
}
//*****************************************************************************

#endif
